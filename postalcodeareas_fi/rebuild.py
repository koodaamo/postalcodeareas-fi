import os
import sys
import ssl
import json
import tempfile
from urllib import request
from urllib.parse import urlencode, quote_plus
import click
from postalcodeareas_fi.util import polygon_center

TEMPDIR = tempfile.gettempdir() + os.path.sep
FUSION_CACHE = TEMPDIR + "postal_areas_fusion.json"
PAAVO_CACHE = TEMPDIR + "postal_areas_paavo.json"

ENDPOINT = "www.googleapis.com/fusiontables/v2/query"
ID = "1m9trydaf6rdt9qBfQkU-4iRKkhNn6O1lRw7XWnXF"
QUERY = quote_plus(f"SELECT name, geometry FROM {ID} LIMIT 5")
FT_URL = f"https://{ENDPOINT}?sql={QUERY}"

PAAVO_URL = "http://geo.stat.fi/geoserver/wfs?service=WFS&version=1.0.0&request=GetFeature&typeName=postialue:pno&outputFormat=json"


def cached(func):

   def wrapper(*args, **kwargs):

      try:
         disabled = kwargs.pop("disable_cache")
      except:
         disabled = False

      try:
         overwrite = kwargs.pop("overwrite_cache")
      except:
         overwrite = False

      CACHE = kwargs.pop("cache_file")

      exists = os.path.exists(CACHE)

      if disabled or overwrite or not exists:
         data = func(*args, **kwargs)

      if overwrite:
         with open(CACHE, "w") as cachefile:
            cachefile.write(data.decode("utf-8"))
      elif not disabled and exists:
         with open(CACHE) as cachefile:
            data = cachefile.read()
      elif not disabled and not exists:
         with open(CACHE, "w") as cachefile:
            cachefile.write(data.decode("utf-8"))

      return data

   return wrapper

@cached
def fetch_fusiontable(apikey):
   url = FT_URL + f"&key={apikey}"
   ctx = ssl.create_default_context()
   ctx.check_hostname = False
   ctx.verify_mode = ssl.CERT_NONE
   resource = request.urlopen(url, context=ctx)
   return resource.read()


def parse_fusiontable_areas(data):
   "parse the particular table generated by duukkis"
   for area in data["rows"]:
      postalcode = area[0].zfill(5)
      polygon = area[1]["geometry"]["coordinates"][0]
      coordinates = [(x,y) for (x, y, z) in polygon]
      yield (postalcode, coordinates)


@cached
def fetch_paavo():
   resource = request.urlopen(PAAVO_URL)
   return resource.read()

def parse_paavo_areas(data):
   for area in data["features"]:
      postalcode = area["properties"]["posti_alue"]
      coordinates = area["geometry"]["coordinates"][0][0]
      yield (postalcode, coordinates)
 

@click.command()
@click.argument("source", type=click.Choice(['FUSION', 'PAAVO']))
@click.option("--apikey")
@click.option("--cache", is_flag=True, default=False, help="Cache source data & use existing cache")
@click.option("--overwrite", is_flag=True, default=False, help="Overwrite the cache")
@click.option("--clear", is_flag=True, default=False, help="Remove the cache")
def rebuild(source, apikey, cache, overwrite, clear):

   # fetch and parse, with caching

   if clear:
      try:
         os.remove(FUSION_CACHE)
      except:
         pass
      else:
         click.echo("Cache removed")
      try:
         os.remove(PAAVO_CACHE)
      except:
         pass
      else:
         click.echo("Cache removed")

   disable = not cache
   if cache:
      click.echo("Using cache")
   if overwrite:
      click.echo("Overwriting existing cache")

   if source == "FUSION":
      data = fetch_fusiontable(apikey, disable_cache=disable, overwrite_cache=overwrite, cache_file=FUSION_CACHE)
      parser = parse_fusiontable_areas
   elif source == "PAAVO":
      data = fetch_paavo(disable_cache=disable, overwrite_cache=overwrite, cache_file=PAAVO_CACHE)
      parser = parse_paavo_areas
   else:
      click.echo("Unknown source, exiting...")
      sys.exit()

   parsed_json = json.loads(data)

   with open("data.py.in") as tmplfile:
      template = tmplfile.read()

   arealist = []
   centerlist = []

   for postalcode, coordinates in parser(parsed_json):
      coordinatetuples = ', '.join((f"({x}, {y})" for (x, y) in coordinates))
      arealist.append(f'   "{postalcode}": ({coordinatetuples}),')
      centerpoint = polygon_center(coordinates)
      centerlist.append(f'   "{postalcode}": {centerpoint},',)

   click.echo("Writing data.py output file")
   with open("data.py", "w") as pyfile:
      output = template % ('\n'.join(arealist), '\n'.join(centerlist))
      pyfile.write(output)


if __name__ == '__main__':
    rebuild()
